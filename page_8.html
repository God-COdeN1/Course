<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Functions start</title>
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <h1>Функції початок</h1>
    <h3>Розпакування і упаковка аргументів</h3>
    <p>
      У Python існує поняття розпакування і упаковки аргументів. Це стосується
      передачі і прийому параметрів в функціях та методах. Давайте розглянемо
      кожне поняття докладніше.
    </p>
    <ul>
      <li>
        Розпакування аргументів (Unpacking Arguments):<br />
        Розпакування аргументів - це спосіб передачі змінної кількості
        аргументів у функцію, яка очікує окремі аргументи. Це зручно
        використовувати, коли ми маємо послідовність значень, таку як кортеж або
        список, і хочемо передати їх як окремі аргументи функції. Приклад
        розпакування кортежу в аргументи функції:
        <!-- exemple_1 -->
        Якщо до кортежу добавити 4 елемент то виникне помилка:<br />
        TypeError: print_coordinates() takes 3 positional arguments but 4 were
        given
      </li>
      <li>
        Упаковка аргументів (Packing Arguments):<br />
        Упаковка аргументів - це здатність функції приймати змінну кількість
        аргументів, які передаються їй при виклику. Ми можемо використовувати
        оператор * (зірочка) для створення кортежу або списку з переданих
        аргументів. Приклад упаковки аргументів в список:
        <!-- exemple_2 -->
        В даному прикладі ми можемо добавляти елементи або видаляти
      </li>
    </ul>
    <h3>Аргументи за замовчуванням, аргументи ключі</h3>
    <p>
      У Python існують два типи аргументів: аргументи за замовчуванням (default
      arguments) і ключові аргументи (keyword arguments). Давайте розглянемо
      кожен тип окремо:
    </p>
    <ul>
      <li>
        Аргументи за замовчуванням (default arguments):<br />
        Аргументи за замовчуванням - це значення, які встановлюються для
        параметрів функції за замовчуванням. Це дозволяє викликати функцію з
        меншою кількістю аргументів, оскільки вони отримають значення за
        замовчуванням, якщо вони не вказані при виклику.
        <!-- exemple_3 -->
        Аргумент message має значення за замовчуванням "Hello", тому якщо його
        не передати при виклику, воно використовуватиметься за замовчуванням.
      </li>
      <li>
        Ключові аргументи (keyword arguments):<br />
        Ключові аргументи дозволяють передавати аргументи до функції, вказуючи
        їхні імена. Це робить виклики функцій більш читабельними, особливо коли
        функція має багато параметрів. Вони також дозволяють передавати
        аргументи у будь-якому порядку.
        <!-- exemple_4   -->
        У цьому прикладі ми вказали імена параметрів при виклику функції, що
        робить код більш зрозумілим, незважаючи на змінений порядок аргументів.
      </li>
    </ul>
    <h3>Область видимості, правило LEGB</h3>
    <p>
      Область видимості та правило LEGB - це поняття, пов'язані з тим, як Python
      визначає, яку змінну використовувати в конкретному місці програми, коли є
      багато змінних з однаковим ім'ям.
    </p>
    <p>
      Правило LEGB визначає порядок пошуку змінних в мові Python і базується на
      чотирьох рівнях видимості:
    </p>
    <ul>
      <li>
        Local (Локальна область видимості): Це область, де змінні визначені
        всередині поточної функції. Вони доступні лише всередині цієї функції.
      </li>
      <li>
        Enclosing (Область видимості замикання): Це область, яка оточує поточну
        функцію, якщо є вкладені функції. Змінні, оголошені у замиканні
        (зовнішній функції), доступні всередині вкладених функцій.
      </li>
      <li>
        Global (Глобальна область видимості): Це область, де змінні оголошуються
        на рівні модуля або у верхньому рівні скрипту. Вони доступні в усій
        програмі.
      </li>
      <li>
        Built-in (Вбудована область видимості): Це область, яка містить
        вбудовані функції та змінні, такі як print(), len(), sum() і т.д. Вони
        доступні в усій програмі.
      </li>
    </ul>
    <!-- exemple_5 -->
    <p>
      У цьому прикладі:<br />
      x знаходиться в глобальній області видимості.<br />
      y знаходиться в області видимості замикання.<br />
      z знаходиться в локальній області видимості функції inner.<br />
    </p>
    <p>
      Таким чином, правило LEGB визначає порядок пошуку змінних в зазначених
      чотирьох рівнях видимості.
    </p>
    <h3>Локальні і глобальні змінні у функціях</h3>
    <p>
      Локальні та глобальні змінні визначаються у різних областях видимості і
      мають різний час життя. Давайте розглянемо різницю між ними:
    </p>
    <ul>
      <li>
        Локальні змінні:
        <ul>
          <li>
            Локальні змінні визначаються всередині функції і доступні лише в
            межах цієї функції.
          </li>
          <li>
            Вони існують лише під час виконання функції та виготовляються
            пам'ять, коли функція викликається і звільняються після завершення
            функції.
          </li>
          <li>Локальні змінні не доступні ззовні функції.</li>
          <li>
            Вони можуть мати те ж ім'я, що і глобальні змінні, але їх області
            видимості різні.
          </li>
        </ul>
        <!-- exemple_6 -->
      </li>
      <li>
        Глобальні змінні:
        <ul>
          <li>
            Глобальні змінні визначаються на верхньому рівні модуля або файлу і
            доступні в усій програмі, включаючи функції.
          </li>
          <li>Вони зберігаються в пам'яті протягом усього життя програми.</li>
          <li>
            Глобальні змінні можна змінювати та звертатися до них в будь-якому
            місці програми.
          </li>
        </ul>
        <!-- exemple_7 -->
      </li>
    </ul>
    <p>
      Під час використання локальних та глобальних змінних слід бути обережним,
      оскільки неправильне керування змінними може призвести до небажаних
      результатів. Краще використовувати передачу аргументів у функції та
      повертати значення, коли це можливо, замість зміни глобальних змінних
      всередині функцій.
    </p>
    <h3>Функції як об'єкти першого класу</h3>
    <p>
      Функції є об'єктами першого класу (first-class objects). Це означає, що
      функції можна розглядати як будь-який інший тип даних, такий як рядки,
      числа чи списки, і їх можна передавати, повертати, зберігати у змінних та
      використовувати як аргументи для інших функцій.<br />
      Ось деякі характеристики функцій як об'єктів першого класу:
    </p>
    <ul>
      <li>
        Присвоєння змінних:<br />
        Ви можете призначити функцію змінній, так само як інший об'єкт. Це
        дозволяє вам використовувати змінну для виклику функції.
        <!-- exemple_8 -->
      </li>
      <li>
        Передача в якості аргументів:<br />
        Функції можна передавати в інші функції як аргументи. Це
        використовується для реалізації функцій вищого порядку.
        <!-- exemple_9 -->
      </li>
      <li>
        Повернення з функцій:<br />
        Функції можуть повертати інші функції в якості результатів.
        <!-- exemple_10 -->
      </li>
      <li>
        Зберігання в структурах даних:<br />
        Функції можуть бути збережені в списках, словниках або інших структурах
        даних.
        <!-- exemple_11 -->
      </li>
    </ul>
    <h3>Рекурсія</h3>
    <p>
      Рекурсія - це техніка в програмуванні, коли функція викликає саму себе для
      вирішення певної задачі чи обчислення значення. Функції, які
      використовують такий підхід, називаються рекурсивними функціями. Рекурсія
      може бути дуже потужним інструментом у програмуванні, особливо для
      розв'язання завдань, які можуть бути поділені на менші аналогічні
      частини.<br />
      Основні характеристики рекурсії:
    </p>
    <ul>
      <li>
        Базовий випадок: Кожна рекурсивна функція повинна мати базовий
        (термінальний) випадок, коли рекурсія завершується. Без цього рекурсивна
        функція буде викликатися безкінечно, і це призведе до переповнення
        стеку.
      </li>
      <li>
        Рекурсивний виклик: Функція повинна викликати саму себе зі зміненими
        аргументами так, щоб при найбільшому базовому випадку рекурсія
        завершилася.
      </li>
    </ul>
    <p>Основні приклади використання рекурсії:</p>
    <ul>
      <li>
        Факторіал числа: Рекурсивна функція для обчислення факторіала числа n,
        яка визначається як добуток всіх цілих чисел від 1 до n.
        <!-- exemple_12 -->
      </li>
      <li>
        Сума чисел: Рекурсивна функція для обчислення суми перших n натуральних
        чисел.
        <!-- exemple_13 -->
      </li>
      <li>
        Пошук у глибину (DFS): В алгоритмі пошуку у глибину для обходу графів
        використовується рекурсія.
      </li>
    </ul>
    <p>
      Рекурсія дозволяє зручно розв'язувати завдання, які мають рекурсивну
      природу або можуть бути розкладені на менші аналогічні задачі. Проте
      важливо використовувати її обережно, оскільки неправильне використання
      може призвести до переповнення стеку та інших проблем з продуктивністю
      програми.
    </p>
  </body>
</html>
