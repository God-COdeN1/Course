<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Sorting algorithms</title>
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <h1>Алгоритми сортування</h1>
    <h3>Оптимальність</h3>
    <h3>Алгоритми сортування</h3>
    <p>
      Алгоритми сортування - це методи організації елементів у списку або масиві
      у певному порядку (наприклад, за зростанням чи спаданням значень). Це
      допомагає впорядкувати дані, щоб легше знаходити, вставляти, видаляти
      елементи та виконувати різні операції з ними.<br />
      У Python існує кілька вбудованих алгоритмів сортування, таких як:
    </p>
    <ul>
      <li>Сортування бульбашкою (Bubble Sort)</li>
      <li>Сортування вибором (Selection Sort)</li>
      <li>Сортування вставкою (Insertion Sort)</li>
      <li>Сортування злиттям (Merge Sort)</li>
      <li>Швидке сортування (Quick Sort)</li>
      <li>
        Сортування ковзанням (Timsort, який використовується у функції sorted())
      </li>
    </ul>
    <h3>Сортування бульбашкою</h3>
    <p>
      Сортування бульбашкою (Bubble Sort) - це простий алгоритм сортування, де
      ми порівнюємо пари сусідніх елементів у списку і міняємо їх місцями, якщо
      вони не впорядковані у потрібному порядку. Ми повторюємо цей процес для
      всього списку доти, поки список не буде повністю відсортований.<br />
      Ось приклад реалізації сортування бульбашкою в Python:
    </p>
    <!-- exemple_1 -->
    <p>Де:</p>
    <ul>
      <li>
        bubble_sort - це функція, яка приймає на вхід список arr, який ми хочемо
        відсортувати.
      </li>
      <li>
        n = len(arr) - ми визначаємо довжину списку, щоб знати, скільки
        елементів ми маємо сортувати.
      </li>
      <li>
        Перша зовнішня петля for i in range(n): представляє проходи через весь
        список. Кожен прохід цієї петлі буде встановлювати на своєму місці
        найбільший невпорядкований елемент.
      </li>
      <li>
        Друга внутрішня петля for j in range(0, n - i - 1): пройде через
        невпорядковану частину списку, яка зменшується з кожним новим проходом
        зовнішньої петлі. Ми не хочемо порівнювати останній елемент, оскільки
        після попередніх ітерацій найбільший невпорядкований елемент вже буде на
        своєму місці.
      </li>
      <li>
        Умова if arr[j] > arr[j + 1]: порівнює два сусідніх елементи arr[j] і
        arr[j + 1]. Якщо arr[j] більший за arr[j + 1], це означає, що елементи
        не впорядковані і ми міняємо їх місцями, використовуючи конструкцію
        arr[j], arr[j + 1] = arr[j + 1], arr[j].
      </li>
      <li>
        Після завершення всіх проходів зовнішньої петлі, список arr буде
        повністю впорядкованим.
      </li>
      <li>
        Нарешті, ми викликаємо функцію bubble_sort для вхідного списку my_list і
        виводимо відсортований список.
      </li>
    </ul>
    <p>Відсортований список: [11, 12, 22, 25, 34, 64, 90]</p>
    <h3>Сортування злиттям</h3>
    <p>
      Сортування злиттям (Merge Sort) - це ефективний алгоритм сортування, який
      базується на розбитті вихідного списку на менші підсписки, сортуванні їх
      окремо і потім об'єднанні впорядковані підсписки для отримання
      впорядкованого весь список.<br />
      Основна ідея сортування злиттям полягає у такому процесі:
    </p>
    <ul>
      <li>Розділити вихідний список на дві половини.</li>
      <li>Рекурсивно відсортувати кожну половину.</li>
      <li>Об'єднати дві впорядковані половини, здійснивши злиття.</li>
    </ul>
    <p>Ось приклад реалізації сортування злиттям в Python:</p>
    <!-- exemple_2 -->
    <ul>
      <li>
        merge_sort - це головна функція сортування злиттям. Вона рекурсивно
        розділяє вхідний список на менші частини, сортує їх і потім викликає
        функцію merge для об'єднання результатів.
      </li>
      <li>
        merge - це функція, яка об'єднує два впорядкованих підсписки в один
        впорядкований список.
      </li>
      <li>
        Приклад використання показує, як ви можете викликати merge_sort для
        впорядкування списку my_list і отримати відсортований список sorted_list
      </li>
    </ul>
    <p>Відсортований список: [11, 12, 22, 25, 34, 64, 90]</p>
    <h3>Сортування Шелла</h3>
    <p>
      Сортування Шелла (Shell Sort) - це ефективний алгоритм сортування, який є
      вдосконаленим варіантом вставкового сортування. Він використовує ідею
      вставки елементів на віддалених позиціях, що допомагає швидше
      впорядковувати списки, де елементи не рівномірно розподілені.
    </p>
    <p>
      Основна ідея сортування Шелла полягає у використанні "послідовності
      проміжків" (gap sequence), яка визначає, які елементи в списку
      порівнюються та обмінюються. Спочатку алгоритм застосовує вставковий
      сортування з великим проміжком між елементами, а потім поступово зменшує
      проміжок до 1, використовуючи менше зсувів та обмінів. Такий підхід
      допомагає впорядковувати елементи більш швидко, ніж стандартний вставковий
      сортування.<br />
      Ось приклад реалізації сортування Шелла в Python:
    </p>
    <!-- exemple_3 -->
    <ul>
      <li>
        shell_sort - це функція сортування Шелла. Вона використовує
        послідовність проміжків для впорядкування списку.
      </li>
      <li>Починаємо з великого проміжку gap, який поступово зменшуємо.</li>
      <li>
        Внутрішній цикл for i in range(gap, n): проходить через елементи списку,
        починаючи з поточного проміжку gap.
      </li>
      <li>
        Внутрішній цикл while j >= gap and arr[j - gap] > temp: порівнює
        елементи на віддалених проміжках і обмінює їх, якщо вони не
        впорядковані.
      </li>
      <li>
        Після закінчення внутрішнього циклу, ми вставляємо temp на потрібне
        місце в підсписку.
      </li>
      <li>
        Зменшуємо проміжок gap і продовжуємо цей процес доки gap не стане 0.
      </li>
    </ul>
    <p>Відсортований список: [11, 12, 22, 25, 34, 64, 90]</p>
    <h3>Пірамідальне сортування</h3>
    <p>
      Пірамідальне сортування (Heap Sort) - це алгоритм сортування, який
      використовує структуру даних піраміда (heap) для ефективного впорядкування
      елементів. Піраміда - це деревоподібна структура даних, в якій кожен вузол
      має значення, менше або рівне значенням його дочірніх вузлів (якщо такі
      існують).<br />
      Основна ідея пірамідального сортування полягає у такому процесі:
    </p>
    <ul>
      <li>Спочатку будується піраміда з вихідного списку.</li>
      <li>
        Найбільший елемент (корінь піраміди) переміщається на останнє місце в
        списку і видаляється з піраміди.
      </li>
      <li>
        Після видалення кореня піраміда може втратити своє властивесть, тому
        виконується операція "просіювання вниз", щоб відновити властивість
        піраміди.
      </li>
      <li>
        Повторюється крок 2 та крок 3 до тих пір, поки піраміда не опорожниться.
      </li>
      <li>
        Всі видалені елементи вставляються на правильні місця у відсортованому
        списку.
      </li>
    </ul>
    <p>Ось приклад реалізації пірамідального сортування в Python:</p>
    <!-- exemple_4 -->
    <ul>
      <li>
        heapify - це функція, яка допомагає відновити властивість піраміди у
        піддереві з коренем в індексі i.
      </li>
      <li>
        heap_sort - головна функція пірамідального сортування. Спочатку
        будується максимальна піраміда, а потім видаляються елементи з піраміди
        та вставляються у відсортований список.
      </li>
      <li>
        Приклад використання показує, як викликати heap_sort для впорядкування
        списку my_list і отримати відсортований список.
      </li>
    </ul>
    <p>Відсортований список: [11, 12, 22, 25, 34, 64, 90]</p>
    <h3>Швидке сортування</h3>
    <p>
      Швидке сортування (Quick Sort) - це ефективний алгоритм сортування, який
      використовує підхід "розділяй і володарюй". Він розбиває вихідний список
      на менші підсписки, сортує їх окремо і об'єднує їх для отримання
      впорядкованого списку.<br />
      Основна ідея швидкого сортування полягає у такому процесі:
    </p>
    <ul>
      <li>Обираємо один елемент списку як "опорний" (pivot).</li>
      <li>
        Розбиваємо список на дві частини: елементи менше опорного і елементи
        більше опорного.
      </li>
      <li>Рекурсивно сортуємо обидві частини.</li>
      <li>Об'єднуємо впорядковані частини разом.</li>
    </ul>
    <p>Ось приклад реалізації швидкого сортування в Python:</p>
    <!-- exemple_5 -->
    <ul>
      <li>
        quick_sort - це головна функція швидкого сортування. Вона рекурсивно
        розбиває список на менші частини, сортує їх та об'єднує результат.
      </li>
      <li>Опорний елемент (pivot) обирається з середини списку.</li>
      <li>
        Створюються три підсписки: left (менше опорного), middle (рівні
        опорному) і right (більше опорного).
      </li>
      <li>
        Результати рекурсивних викликів quick_sort для підсписків left і right
        об'єднуються разом з middle, щоб отримати впорядкований список.
      </li>
    </ul>
    <p>Відсортований список: [11, 12, 22, 25, 34, 64, 90]</p>
  </body>
</html>
